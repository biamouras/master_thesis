# agrega as matrizes n zonas vezes
slice(rep(1, each = length(setores))) %>%
as.matrix(.)
# define os nomes
rownames(weight_init) <- setores
# verifica se tem alguma variável faltando
vars_faltando <- var_restritivas[!(var_restritivas %in% colnames(weight_init))]
if(!identical(vars_faltando, character(0))){
new_cols <- matrix(0,
nrow = nrow(weight_init),
ncol = length(vars_faltando),
dimnames = list(setores, vars_faltando))
weight_init <- cbind(weight_init, new_cols)
}
# reordena as colunas
weight_init <- weight_init[, var_restritivas]
# alvo de valores totais de cada setor
target <- list(as.matrix(universo_ap))
# ordem das variáveis restritivas
descript <- list(1:2)
## implementação do Ipf ----
weight_mipfp <- Ipfp(seed = weight_init,
target.list = descript,
target.data = target,
na.target = T, tol = 1e-5)
## inteirização por Truncate, Replicate, Sample ----
weight_mipfp <- int_trs(weight_mipfp$x.hat)
## expansão e total da variável alvo por setor ----
df <- as.data.frame.table(weight_mipfp) %>%
left_join(amostra_ap, by = c('Var2' = 'v_restritiva')) %>%
mutate(peso = Freq) %>%
group_by(Var1, v_alvo) %>%
summarise(total = sum(peso), .groups = 'drop_last') %>%
rename(Cod_setor = Var1) %>%
pivot_wider(
id_cols = 'Cod_setor',
names_from = 'v_alvo',
values_from = 'total',
values_fill = 0
)
df
})
# total de domicílios
sum(setor_grupos[,c('G1', 'G2', 'G3')])
sum(setor_grupos_mestrado[,c('G1', 'G2', 'G3')], na.rm= T)
setor_grupos_mestrado <- read_csv('./data/population/population_micro_censustract.csv')
sum(setor_grupos_mestrado[,c('G1', 'G2', 'G3')], na.rm= T)
message(ap)
# seleciona os setores de uma AP no universo
setores <- relacao_areap_setor %>%
filter(`Área de ponderação` == ap) %>%
.$Setor
universo_ap <- df_universo_rest %>%
filter(Cod_setor %in% setores) %>%
select(-Cod_setor)
# seleciona os indivíduos da AP
amostra_ap <- df_amostra_sp %>%
filter(V0011 == ap)
weight_init <-  amostra_ap %>%
# matriz inicial para cada zona
pivot_wider(
id_cols = 'V0011',
names_from = 'v_restritiva',
values_from = 'V0010', # considera o peso
values_fn = sum
) %>%
select(-V0011) %>%
# agrega as matrizes n zonas vezes
slice(rep(1, each = length(setores))) %>%
as.matrix(.)
weight_init
# define os nomes
rownames(weight_init) <- setores
weight_init
weight_init <-  amostra_ap %>%
# matriz inicial para cada zona
pivot_wider(
id_cols = 'V0011',
names_from = 'v_restritiva',
values_from = 'V0010', # considera o peso
values_fn = sum
) %>%
select(-V0011) %>%
# agrega as matrizes n zonas vezes
slice(rep(1, each = length(setores))) %>%
as.matrix(.)
# verifica se tem alguma variável faltando
vars_faltando <- var_restritivas[!(var_restritivas %in% colnames(weight_init))]
if(!identical(vars_faltando, character(0))){
new_cols <- matrix(0,
nrow = nrow(weight_init),
ncol = length(vars_faltando),
dimnames = list(setores, vars_faltando))
weight_init <- cbind(weight_init, new_cols)
}
# reordena as colunas
weight_init <- weight_init[, var_restritivas]
head(weight_init)
?table
?summary.table
table(head(amostra_ap[,c('v_restritiva', 'v_alvo')]))
weight_init <- table(amostra_ap[,c('v_restritiva', 'v_alvo')])
# alvo de valores totais de cada setor
target <- list(as.matrix(universo_ap))
# ordem das variáveis restritivas
descript <- list(1)
## implementação do Ipf ----
weight_mipfp <- Ipfp(seed = weight_init,
target.list = descript,
target.data = target,
na.target = T, tol = 1e-5)
weight_mipfp$check.margins
weight_init <- rep(table(amostra_ap[,c('v_restritiva', 'v_alvo')]),
length(setores))
weight_init
weight_init <- rep(table(amostra_ap[,c('v_restritiva', 'v_alvo')]),
each = length(setores))
weight_init
weight_init <- table(amostra_ap[,c('v_restritiva', 'v_alvo')])
weight_zones <- rep(weight_init,
each = length(setores))
weight_zones
weight_init
weight_zones <- array(weight_zones,
dim = c(length(setores), length(var_restritivas), 3))
weight_zones
weight_init <- table(amostra_ap[,c('v_restritiva', 'v_alvo')])
weight_zones <- rep(weight_init,
each = length(setores))
weight_zones <- array(weight_zones,
dim = c(length(setores), length(var_restritivas), 3),
names = c(list(setores), as.list(dimnames(weight_init))))
weight_zones <- rep(weight_init,
each = length(setores))
weight_zones <- array(weight_zones,
dim = c(length(setores), length(var_restritivas), 3),
dimnames = c(list(setores), as.list(dimnames(weight_init))))
weight_zones
# alvo de valores totais de cada setor
target <- list(as.matrix(universo_ap))
target
weight_init <- table(amostra_ap[,c('v_restritiva', 'v_alvo')])
weight_init
length(setores)
weight_zones <- rep(weight_init,
each = length(setores))
weight_zones <- array(weight_zones,
dim = c(length(setores), length(var_restritivas), 3),
dimnames = c(list(setores), as.list(dimnames(weight_init))))
weight_zones
weight_zones[,,3]
# alvo de valores totais de cada setor
target <- list(as.matrix(universo_ap))
# ordem das variáveis restritivas
descript <- list(1)
## implementação do Ipf ----
weight_mipfp <- Ipfp(seed = weight_zones,
target.list = descript,
target.data = target,
na.target = T, tol = 1e-5)
## inteirização por Truncate, Replicate, Sample ----
weight_mipfp <- lapply(weight_mipfp, FUN = function(x) int_trs(x$x.hat))
head(weight_mipfp)
weight_mipfp$x.hat
## inteirização por Truncate, Replicate, Sample ----
weight_mipfp <- apply(weight_mipfp, MARGIN = 1, function(x) int_trs(x$x.hat))
weight_mipfp$x.hat[1,,]
## inteirização por Truncate, Replicate, Sample ----
weight_mipfp <- apply(weight_mipfp$x.hat, MARGIN = 1, int_trs)
ind_mipfp <- int_expand_array(weight_mipfp)
ind_mipfp <- int_expand_array(weight_mipfp)
ind_mipfp
as.data.frame.table(weight_mipfp)
weight_mipfp
head(weight_mipfp)
## implementação do Ipf ----
weight_mipfp <- Ipfp(seed = weight_zones,
target.list = descript,
target.data = target,
na.target = T, tol = 1e-5)
## inteirização por Truncate, Replicate, Sample ----
weight_mipfp <- t(apply(weight_mipfp$x.hat, MARGIN = 1, int_trs))
weight_mipfp
## implementação do Ipf ----
weight_mipfp <- Ipfp(seed = weight_zones,
target.list = descript,
target.data = target,
na.target = T, tol = 1e-5)
weight_mipfp
## inteirização por Truncate, Replicate, Sample ----
weight_mipfp <- weight_mipfp$x.hat
weight_mipfp
# ordem das variáveis restritivas
descript <- list(2)
# ordem das variáveis restritivas
descript <- list(1,2)
## implementação do Ipf ----
weight_mipfp <- Ipfp(seed = weight_zones,
target.list = descript,
target.data = target,
na.target = T, tol = 1e-5)
# ordem das variáveis restritivas
descript <- list(1:2)
## implementação do Ipf ----
weight_mipfp <- Ipfp(seed = weight_zones,
target.list = descript,
target.data = target,
na.target = T, tol = 1e-5)
weight_mipfp <- weight_mipfp$x.hat
## inteirização por Truncate, Replicate, Sample ----
walk(setores, function(setor){
weight_mipfp[setor,,,] <- int_trs(weight_mipfp[setor,,,])
})
## inteirização por Truncate, Replicate, Sample ----
walk(setores, function(setor){
weight_mipfp[setor,,] <- int_trs(weight_mipfp[setor,,])
})
setor <- setores[1]
setor
weight_mipfp <- weight_mipfp$x.hat
## implementação do Ipf ----
weight_mipfp <- Ipfp(seed = weight_zones,
target.list = descript,
target.data = target,
na.target = T, tol = 1e-5)
weight_mipfp <- weight_mipfp$x.hat
weight_mipfp[setor,,]
weight_mipfp[1,,]
weight_mipfp[as.character(setor),,] <- int_trs(weight_mipfp[setor,,])
## implementação do Ipf ----
weight_mipfp <- Ipfp(seed = weight_zones,
target.list = descript,
target.data = target,
na.target = T, tol = 1e-5)
weight_mipfp <- weight_mipfp$x.hat
## inteirização por Truncate, Replicate, Sample ----
walk(setores, function(setor){
weight_mipfp[as.character(setor),,] <- int_trs(weight_mipfp[as.character(setor),,])
})
weight_mipfp[as.character(setor),,]
## expansão e total da variável alvo por setor ----
ind_mipfp <- int_expand_array(weight_mipfp)
ind_mipfp
as.data.frame.table(weight_mipfp)
## expansão e total da variável alvo por setor ----
setores_mipfp <- as.data.frame.table(weight_mipfp) %>%
rename(peso = Freq,
Cod_setor) %>%
group_by(Cod_setor, v_alvo) %>%
summarise(total = sum(peso), .groups = 'drop_last') %>%
pivot_wider(
id_cols = 'Cod_setor',
names_from = 'v_alvo',
values_from = 'total',
values_fill = 0
)
## expansão e total da variável alvo por setor ----
setores_mipfp <- as.data.frame.table(weight_mipfp) %>%
rename(peso = Freq,
Cod_setor = Var1) %>%
group_by(Cod_setor, v_alvo) %>%
summarise(total = sum(peso), .groups = 'drop_last') %>%
pivot_wider(
id_cols = 'Cod_setor',
names_from = 'v_alvo',
values_from = 'total',
values_fill = 0
)
setores_mipf
setores_mipfp
source("D:/OneDrive/Pesquisa/master_thesis/rscript/02_processamento/01_microssimulation_prep_data.R", echo=TRUE)
# total de domicílios
sum(setor_grupos[,c('G1', 'G2', 'G3')])
sum(setor_grupos_mestrado[,c('G1', 'G2', 'G3')], na.rm= T)
?Ipfp
ap <- 3550308005257
message(ap)
# seleciona os setores de uma AP no universo
setores <- relacao_areap_setor %>%
filter(`Área de ponderação` == ap) %>%
.$Setor
universo_ap <- df_universo_rest %>%
filter(Cod_setor %in% setores) %>%
select(-Cod_setor)
# seleciona os indivíduos da AP
amostra_ap <- df_amostra_sp %>%
filter(V0011 == ap)
## estrutura os dados de entrada ----
weight_init <- table(amostra_ap[,c('v_restritiva', 'v_alvo')])
weight_zones <- rep(weight_init,
each = length(setores))
weight_zones <- array(weight_zones,
dim = c(length(setores), length(var_restritivas), 3),
dimnames = c(list(setores), as.list(dimnames(weight_init))))
# alvo de valores totais de cada setor
target <- list(as.matrix(universo_ap))
# ordem das variáveis restritivas
descript <- list(1:2)
## implementação do Ipf ----
weight_mipfp <- Ipfp(seed = weight_zones,
target.list = descript,
target.data = target,
na.target = T, tol = 1e-5)
weight_mipfp
weight_mipfp$error.margins
weight_mipfp <- weight_mipfp$x.hat
## inteirização por Truncate, Replicate, Sample ----
walk(setores, function(setor){
weight_mipfp[as.character(setor),,] <- int_trs(weight_mipfp[as.character(setor),,])
})
universo_ap <- df_universo_rest %>%
filter(Cod_setor %in% setores)
universo_ap[,-'Cod_setor']
# alvo de valores totais de cada setor
target <- list(as.matrix(universo_ap[,-c('Cod_setor')]))
head(universo_ap)
# alvo de valores totais de cada setor
target <- list(as.matrix(universo_ap[,c(1:10)]))
target
## expansão e total da variável alvo por setor ----
# margens do universo
margens_universo <- universo_ap %>%
mutate(total_uni = sum(V014:V013)) %>%
select(Cod_setor, total_uni)
margens_universo
## expansão e total da variável alvo por setor ----
# margens do universo
margens_universo <- universo_ap %>%
mutate(total_uni = rowSums(V014:V013)) %>%
select(Cod_setor, total_uni)
universo_ap <- df_universo_rest %>%
filter(Cod_setor %in% setores) %>%
select(-Cod_setor)
## expansão e total da variável alvo por setor ----
# margens do universo
margens_universo <- data.frame(Cod_setor = universo_ap$Cod_setor,
total_uni = rowSums(universo_ap))
## expansão e total da variável alvo por setor ----
# margens do universo
margens_universo <- data.frame(Cod_setor = rownames(universo_ap),
total_uni = rowSums(universo_ap))
margens_universo
setores_mipfp <- as.data.frame.table(weight_mipfp) %>%
rename(peso = Freq,
Cod_setor = Var1) %>%
group_by(Cod_setor, v_alvo) %>%
summarise(total = sum(peso), .groups = 'drop_last') %>%
pivot_wider(
id_cols = 'Cod_setor',
names_from = 'v_alvo',
values_from = 'total',
values_fill = 0
) %>%
ungroup() %>%
mutate(total_sim = G1+G2+G3) %>%
left_join(margens_universo) %>%
mutate(erro = total_uni - total_sim)
setores_mipfp
setor_grupos <- map_df(areas_ponderacao, function(ap){
message(ap)
# seleciona os setores de uma AP no universo
setores <- relacao_areap_setor %>%
filter(`Área de ponderação` == ap) %>%
.$Setor
universo_ap <- df_universo_rest %>%
filter(Cod_setor %in% setores) %>%
select(-Cod_setor)
# seleciona os indivíduos da AP
amostra_ap <- df_amostra_sp %>%
filter(V0011 == ap)
## estrutura os dados de entrada ----
weight_init <- table(amostra_ap[,c('v_restritiva', 'v_alvo')])
weight_zones <- rep(weight_init,
each = length(setores))
weight_zones <- array(weight_zones,
dim = c(length(setores), length(var_restritivas), 3),
dimnames = c(list(setores), as.list(dimnames(weight_init))))
# alvo de valores totais de cada setor
target <- list(as.matrix(universo_ap)) # remove Cod_setor
# ordem das variáveis restritivas
descript <- list(1:2)
## implementação do Ipf ----
weight_mipfp <- Ipfp(seed = weight_zones,
target.list = descript,
target.data = target,
na.target = T, tol = 1e-5)
weight_mipfp <- weight_mipfp$x.hat
## inteirização por Truncate, Replicate, Sample ----
walk(setores, function(setor){
weight_mipfp[as.character(setor),,] <- int_trs(weight_mipfp[as.character(setor),,])
})
## expansão e total da variável alvo por setor ----
# margens do universo
margens_universo <- data.frame(Cod_setor = rownames(universo_ap),
total_uni = rowSums(universo_ap))
setores_mipfp <- as.data.frame.table(weight_mipfp) %>%
rename(peso = Freq,
Cod_setor = Var1) %>%
group_by(Cod_setor, v_alvo) %>%
summarise(total = sum(peso), .groups = 'drop_last') %>%
pivot_wider(
id_cols = 'Cod_setor',
names_from = 'v_alvo',
values_from = 'total',
values_fill = 0
) %>%
ungroup() %>%
mutate(total_sim = G1+G2+G3) %>%
left_join(margens_universo) %>%
mutate(erro = total_uni - total_sim)
setores_mipfp
})
sum(setor_grupos[,'erro'])
sum(setor_grupos[,'erro'], na.rm=T)
# total de domicílios
sum(setor_grupos[,c('G1', 'G2', 'G3')])
head(df_universo_rest)
sum(df_universo_rest[, c(1:10)])
sum(df_universo_rest[, c(1:10)], na.rm = T)
head(setor_grupos)
sum(setor_grupos[,'total_sim'])
sum(setor_grupos[,'total_uni'])
sum(setor_grupos[,'total_uni'], na.rm = T)
filter(setor_grupos, is.na(total_uni))
df_universo_rest <- df_universo %>%
select(
all_of(c(
'Cod_setor',
'V014',
paste0('V', str_pad(5:13, 3, pad = '0'))
))) %>%
column_to_rownames('Cod_setor') %>%
mutate(Cod_setor = rownames(.)) %>%
drop_na()
# corrige os setores para adequar à mesma quantidade do universo
setores <- setores[setores %in% rownames(universo_ap)]
setores
setores_mipfp <- as.data.frame.table(weight_mipfp) %>%
rename(peso = Freq,
Cod_setor = Var1) %>%
group_by(Cod_setor, v_alvo) %>%
summarise(total = sum(peso), .groups = 'drop_last') %>%
pivot_wider(
id_cols = 'Cod_setor',
names_from = 'v_alvo',
values_from = 'total',
values_fill = 0
) %>%
ungroup() %>%
mutate(total_sim = G1+G2+G3) %>%
left_join(margens_universo, by = Cod_setor) %>%
mutate(erro = total_uni - total_sim)
setor_grupos <- map_df(areas_ponderacao, function(ap){
message(ap)
# seleciona os setores de uma AP no universo
setores <- relacao_areap_setor %>%
filter(`Área de ponderação` == ap) %>%
.$Setor
universo_ap <- df_universo_rest %>%
filter(Cod_setor %in% setores) %>%
select(-Cod_setor)
# corrige os setores para adequar à mesma quantidade do universo
setores <- setores[setores %in% rownames(universo_ap)]
# seleciona os indivíduos da AP
amostra_ap <- df_amostra_sp %>%
filter(V0011 == ap)
## estrutura os dados de entrada ----
weight_init <- table(amostra_ap[,c('v_restritiva', 'v_alvo')])
weight_zones <- rep(weight_init,
each = length(setores))
weight_zones <- array(weight_zones,
dim = c(length(setores), length(var_restritivas), 3),
dimnames = c(list(setores), as.list(dimnames(weight_init))))
# alvo de valores totais de cada setor
target <- list(as.matrix(universo_ap)) # remove Cod_setor
# ordem das variáveis restritivas
descript <- list(1:2)
## implementação do Ipf ----
weight_mipfp <- Ipfp(seed = weight_zones,
target.list = descript,
target.data = target,
tol = 1e-5)
weight_mipfp <- weight_mipfp$x.hat
## inteirização por Truncate, Replicate, Sample ----
walk(setores, function(setor){
weight_mipfp[as.character(setor),,] <- int_trs(weight_mipfp[as.character(setor),,])
})
## expansão e total da variável alvo por setor ----
# margens do universo
margens_universo <- data.frame(Cod_setor = rownames(universo_ap),
total_uni = rowSums(universo_ap))
setores_mipfp <- as.data.frame.table(weight_mipfp) %>%
rename(peso = Freq,
Cod_setor = Var1) %>%
group_by(Cod_setor, v_alvo) %>%
summarise(total = sum(peso), .groups = 'drop_last') %>%
pivot_wider(
id_cols = 'Cod_setor',
names_from = 'v_alvo',
values_from = 'total',
values_fill = 0
) %>%
ungroup() %>%
mutate(total_sim = G1+G2+G3) %>%
left_join(margens_universo, by = 'Cod_setor') %>%
mutate(erro = total_uni - total_sim)
setores_mipfp
})
# total de domicílios
sum(setor_grupos[,c('G1', 'G2', 'G3')])
setor_grupos_mestrado <- read_csv('./data/population/population_micro_censustract.csv')
sum(setor_grupos_mestrado[,c('G1', 'G2', 'G3')], na.rm= T)
