# matriz inicial para cada zona
pivot_wider(
id_cols = 'V0011',
names_from = 'v_restritiva',
values_from = 'V0010', # considera o peso
values_fn = sum
) %>%
select(-V0011) %>%
as.matrix(.)
# retorna na ordem original
x <- x[,var_restritivas]
})
head(weight_final)
# transforma em matriz
weight_final <- matrix(
unlist(weight_final),
ncol = 10,
byrow = T,
dimnames = list(setores, var_restritivas))
head(weight_final)
rowSums(weight_final)
rowSums(target)
sum(target[,1])
sum(target[1,])
head(weight_init)
rowSums(head(weight_init))
rowSums(target)
rowSums(target)/rowSums(weight_init)
weight_int * amostra_ap
weight_int %*% amostra_ap
weight_int
weight_int <- rowSums(target)/rowSums(weight_init)
weight_int %*% amostra_ap
t(weight_int)
weight_int
amostra_ap %>%
mutate(V0010 = V0010 * x)
amostra_weight <- apply(weight_int, MARGIN = 1, function(x){
amostra_ap %>%
mutate(V0010 = V0010 * x)
})
dim(weight_int)
amostra_weight <- lapply(weight_int, MARGIN = 1, function(x){
amostra_ap %>%
mutate(V0010 = V0010 * x)
})
amostra_weight <- lapply(weight_int, FUN = function(x){
amostra_ap %>%
mutate(V0010 = V0010 * x)
})
amostra_weight
## implementação do Ipf ----
#weight_mipfp <- Ipfp(weight_init, descript, target,
#                     na.target = T, tol = 1e-5)
i <- 1
repeat{
# obtem a ponderação de cada zona para aplicar sobre o
# cada indivíduo que se encaixa em determinada categoria
if(i%%2 != 0){
weight_int <- t(apply(target, MARGIN = 1, function(x) x/colSums(weight_init)))
# multiplica os pesos intermediarios cada peso inicial de cada indivíduo,
# para cada setor
amostra_weight <- apply(weight_int, MARGIN = 1, function(x){
amostra_ap %>%
mutate(V0010 = V0010 * x[v_restritiva])
})
} else{
weight_int <- rowSums(target)/rowSums(weight_init)
amostra_weight <- lapply(weight_int, FUN = function(x){
amostra_ap %>%
mutate(V0010 = V0010 * x)
})
}
# soma os pesos novamente (margens)
weight_final <- lapply(amostra_weight, FUN = function(x){
x <- x %>%
# matriz inicial para cada zona
pivot_wider(
id_cols = 'V0011',
names_from = 'v_restritiva',
values_from = 'V0010', # considera o peso
values_fn = sum
) %>%
select(-V0011) %>%
as.matrix(.)
# retorna na ordem original
x <- x[,var_restritivas]
})
# transforma em matriz
weight_final <- matrix(
unlist(weight_final),
ncol = 10,
byrow = T,
dimnames = list(setores, var_restritivas))
tol <- norm(weight_final-weight_init)
message(paste0('iteration ', i,': ', tol))
if(tol < 1e-5){
message('END!!!')
break
} else{
weight_init <- weight_final
i <- i+1
}
}
weight_init <-  amostra_ap %>%
# matriz inicial para cada zona
pivot_wider(
id_cols = 'V0011',
names_from = 'v_restritiva',
values_from = 'V0010', # considera o peso
values_fn = sum
) %>%
select(-V0011) %>%
# agrega as matrizes n zonas vezes
slice(rep(1, each = length(setores))) %>%
as.matrix(.)
# define os nomes
rownames(weight_init) <- setores
# reordena as colunas
weight_init <- weight_init[, var_restritivas]
# alvo de valores totais de cada setor
target <- as.matrix(universo_ap)
## implementação do Ipf ----
#weight_mipfp <- Ipfp(weight_init, descript, target,
#                     na.target = T, tol = 1e-5)
i <- 1
repeat{
# obtem a ponderação de cada zona para aplicar sobre o
# cada indivíduo que se encaixa em determinada categoria
if(i%%2 != 0){
weight_int <- t(apply(target, MARGIN = 1, function(x) x/colSums(weight_init)))
# multiplica os pesos intermediarios cada peso inicial de cada indivíduo,
# para cada setor
amostra_weight <- apply(weight_int, MARGIN = 1, function(x){
amostra_ap %>%
mutate(V0010 = V0010 * x[v_restritiva])
})
} else{
weight_int <- rowSums(target)/rowSums(weight_init)
amostra_weight <- lapply(weight_int, FUN = function(x){
amostra_ap %>%
mutate(V0010 = V0010 * x)
})
}
# soma os pesos novamente (margens)
weight_final <- lapply(amostra_weight, FUN = function(x){
x <- x %>%
# matriz inicial para cada zona
pivot_wider(
id_cols = 'V0011',
names_from = 'v_restritiva',
values_from = 'V0010', # considera o peso
values_fn = sum
) %>%
select(-V0011) %>%
as.matrix(.)
# retorna na ordem original
x <- x[,var_restritivas]
})
# transforma em matriz
weight_final <- matrix(
unlist(weight_final),
ncol = 10,
byrow = T,
dimnames = list(setores, var_restritivas))
tol <- norm(weight_final-weight_init)
message(paste0('iteration ', i,': ', tol))
if(tol < 1e-5){
message('END!!!')
break
} else{
weight_init <- weight_final
i <- i+1
}
}
weight_init <-  amostra_ap %>%
# matriz inicial para cada zona
pivot_wider(
id_cols = 'V0011',
names_from = 'v_restritiva',
values_from = 'V0010', # considera o peso
values_fn = sum
) %>%
select(-V0011) %>%
# agrega as matrizes n zonas vezes
slice(rep(1, each = length(setores))) %>%
as.matrix(.)
# define os nomes
rownames(weight_init) <- setores
# reordena as colunas
weight_init <- weight_init[, var_restritivas]
# alvo de valores totais de cada setor
target <- as.matrix(universo_ap)
## implementação do Ipf ----
#weight_mipfp <- Ipfp(weight_init, descript, target,
#                     na.target = T, tol = 1e-5)
i <- 1
# obtem a ponderação de cada zona para aplicar sobre o
# cada indivíduo que se encaixa em determinada categoria
if(i%%2 != 0){
weight_int <- t(apply(target, MARGIN = 1, function(x) x/colSums(weight_init)))
# multiplica os pesos intermediarios cada peso inicial de cada indivíduo,
# para cada setor
amostra_weight <- apply(weight_int, MARGIN = 1, function(x){
amostra_ap %>%
mutate(V0010 = V0010 * x[v_restritiva])
})
} else{
weight_int <- rowSums(target)/rowSums(weight_init)
amostra_weight <- lapply(weight_int, FUN = function(x){
amostra_ap %>%
mutate(V0010 = V0010 * x)
})
}
amostra_weight
head(weight_int)
head(amostra_weight)
# soma os pesos novamente (margens)
weight_final <- lapply(amostra_weight, FUN = function(x){
x <- x %>%
# matriz inicial para cada zona
pivot_wider(
id_cols = 'V0011',
names_from = 'v_restritiva',
values_from = 'V0010', # considera o peso
values_fn = sum
) %>%
select(-V0011) %>%
as.matrix(.)
# retorna na ordem original
x <- x[,var_restritivas]
})
# transforma em matriz
weight_final <- matrix(
unlist(weight_final),
ncol = 10,
byrow = T,
dimnames = list(setores, var_restritivas))
head(weight_final)
tol <- norm(weight_final-weight_init)
message(paste0('iteration ', i,': ', tol))
weight_init <- weight_final
i <- i+1
# obtem a ponderação de cada zona para aplicar sobre o
# cada indivíduo que se encaixa em determinada categoria
if(i%%2 != 0){
weight_int <- t(apply(target, MARGIN = 1, function(x) x/colSums(weight_init)))
# multiplica os pesos intermediarios cada peso inicial de cada indivíduo,
# para cada setor
amostra_weight <- apply(weight_int, MARGIN = 1, function(x){
amostra_ap %>%
mutate(V0010 = V0010 * x[v_restritiva])
})
} else{
weight_int <- rowSums(target)/rowSums(weight_init)
amostra_weight <- lapply(weight_int, FUN = function(x){
amostra_ap %>%
mutate(V0010 = V0010 * x)
})
}
head(weight_int)
head(amostra_weight)
weight_init <-  amostra_ap %>%
# matriz inicial para cada zona
pivot_wider(
id_cols = 'V0011',
names_from = 'v_restritiva',
values_from = 'V0010', # considera o peso
values_fn = sum
) %>%
select(-V0011) %>%
# agrega as matrizes n zonas vezes
slice(rep(1, each = length(setores))) %>%
as.matrix(.)
# define os nomes
rownames(weight_init) <- setores
# reordena as colunas
weight_init <- weight_init[, var_restritivas]
# alvo de valores totais de cada setor
target <- as.matrix(universo_ap)
## implementação do Ipf ----
weight_mipfp <- Ipfp(weight_init, descript, target,
na.target = T, tol = 1e-5)
descript
target
weight_init
# reordena as colunas
weight_init <- list(weight_init[, var_restritivas])
weight_init
# alvo de valores totais de cada setor
target <- list(as.matrix(universo_ap))
# ordem das variáveis restritivas
descript <- list(1:10)
## implementação do Ipf ----
weight_mipfp <- Ipfp(weight_init, descript, target,
na.target = T, tol = 1e-5)
?Ipfp
weight_init <-  amostra_ap %>%
# matriz inicial para cada zona
pivot_wider(
id_cols = 'V0011',
names_from = 'v_restritiva',
values_from = 'V0010', # considera o peso
values_fn = sum
) %>%
select(-V0011) %>%
# agrega as matrizes n zonas vezes
slice(rep(1, each = length(setores))) %>%
as.matrix(.)
# define os nomes
rownames(weight_init) <- setores
# reordena as colunas
weight_init <- weight_init[, var_restritivas]
## implementação do Ipf ----
weight_mipfp <- Ipfp(weight_init, descript, target,
na.target = T, tol = 1e-5)
Ipfp
lenght(target)
length(target)
target
?Ipfp
apply(weight_init, descript[[1]], sum)
# ordem das variáveis restritivas
descript <- list(1:2)
## implementação do Ipf ----
weight_mipfp <- Ipfp(seed = weight_init,
target.list = descript,
target.data = target,
na.target = T, tol = 1e-5)
weight_mipfp
## implementação do Ipf ----
weight_mipfp <- Ipfp(seed = weight_init,
target.list = descript,
target.data = target,
na.target = T, tol = 1e-5,
print = T)
weight_init <-  amostra_ap %>%
# matriz inicial para cada zona
pivot_wider(
id_cols = 'V0011',
names_from = 'v_restritiva',
values_from = 'V0010', # considera o peso
values_fn = sum
) %>%
select(-V0011) %>%
# agrega as matrizes n zonas vezes
slice(rep(1, each = length(setores))) %>%
as.matrix(.)
# define os nomes
rownames(weight_init) <- setores
# reordena as colunas
weight_init <- weight_init[, var_restritivas]
# alvo de valores totais de cada setor
target <- list(as.matrix(universo_ap))
# ordem das variáveis restritivas
descript <- list(1:2)
## implementação do Ipf ----
weight_mipfp <- Ipfp(seed = weight_init,
target.list = descript,
target.data = target,
na.target = T, tol = 1e-5,
print = T)
weight_mipfp
weight_mipfp$x.hat
weight_init <-  amostra_ap %>%
# matriz inicial para cada zona
pivot_wider(
id_cols = 'V0011',
names_from = 'v_restritiva',
values_from = 'peso', # considera o peso
values_fn = sum
) %>%
select(-V0011) %>%
# agrega as matrizes n zonas vezes
slice(rep(1, each = length(setores))) %>%
as.matrix(.)
# define os nomes
rownames(weight_init) <- setores
# reordena as colunas
weight_init <- weight_init[, var_restritivas]
# alvo de valores totais de cada setor
target <- list(as.matrix(universo_ap))
# ordem das variáveis restritivas
descript <- list(1:2)
## implementação do Ipf ----
weight_mipfp <- Ipfp(seed = weight_init,
target.list = descript,
target.data = target,
na.target = T, tol = 1e-5,
print = T)
# Bibliotecas ----
library(tidyverse)
library(sf)
library(mipfp)
ajusta_decimal <- function(x){
# algumas colunas da base da amostra têm casas decimais
# a função vai tratar essas variáveis
# seleciona a linha da variável no dicionário
dic_var <- filter(dic_amostra, VAR == cur_column())
novo_x <- paste0(
str_sub(x, end = dic_var$INT),
'.',
str_sub(x, start = dic_var$INT+1, end = dic_var$INT+dic_var$DEC))
novo_x <- as.numeric(novo_x)
return(novo_x)
}
# dicionário da amostra
dic_amostra <- readxl::read_xls(
'./data/population/census2010/Layout_microdados_Amostra.xls',
sheet = 'DOMI',
range = 'A2:L78'
) %>%
rename(
POSICAO_INICIAL = `POSIÇÃO INICIAL`,
POSICAO_FINAL = `POSIÇÃO FINAL`
) %>%
select(
'VAR', 'NOME', 'POSICAO_INICIAL', 'POSICAO_FINAL',	'INT', 'DEC', 'TIPO'
)
# microdados da amostra
df_amostra <- vroom::vroom_fwf(
file = './data/population/census2010/Amostra_Domicilios_35_RMSP.txt',
col_positions = vroom::fwf_positions(
start = dic_amostra$POSICAO_INICIAL,
end = dic_amostra$POSICAO_FINAL,
col_names = dic_amostra$VAR
),
col_select = c('V0001', 'V0002','V0010', 'V0300',
'V0011', 'V6532', 'V6530')) %>%
# ajustando casas decimais
mutate(
across(
.cols = c('V0010', 'V6532', 'V6530'),
.fns = ajusta_decimal
)
)
df_universo <- read_delim(
'./data/population/census2010/DomicilioRenda_SP1.csv',
delim = ';',
na = 'X'
)
## relação entre áreas de ponderação (amostra) e setores censitários ----
relacao_areap_setor <- read_tsv(
'./data/population/census2010/Composicao das Areas de Ponderacao.txt',
locale = locale(encoding = 'UTF-16')
) %>% #filtra são paulo
filter(str_sub(Setor, 1, 7) == '3550308')
var_restritivas <- c('V014', paste0('V', str_pad(5:13, 3, pad = '0')))
df_amostra_sp <- df_amostra %>%
# filtra município de São Paulo
# filtra domicílios que não responderam a renda
filter(paste0(V0001,V0002) == '3550308',
!is.na(V6532)) %>%
mutate(
# cria relação com os mesmos nomes da universo
v_restritiva = cut(
V6532,
breaks = c(-1, 0, 1/8, 1/4, 1/2, 1, 2, 3, 5, 10, 2000),
labels = var_restritivas,
),
# variavel de interesse da microssimulação
# renda domiciliar bruta em salários mínimos
v_alvo = cut(
V6530,
breaks = c(-1, 3, 10, 4000),
labels = c('G1', 'G2', 'G3')
))
df_universo_rest <- df_universo %>%
select(
all_of(c(
'Cod_setor',
'V014',
paste0('V', str_pad(5:13, 3, pad = '0'))
))) %>%
column_to_rownames('Cod_setor') %>%
mutate(Cod_setor = rownames(.))
# seleciona os setores de uma AP no universo
setores <- relacao_areap_setor %>%
filter(`Área de ponderação` == ap) %>%
.$Setor
universo_ap <- df_universo_rest %>%
filter(Cod_setor %in% setores) %>%
select(-Cod_setor)
# seleciona os indivíduos da AP
amostra_ap <- df_amostra_sp %>%
filter(V0011 == ap)
weight_init <-  amostra_ap %>%
# matriz inicial para cada zona
pivot_wider(
id_cols = 'V0011',
names_from = 'v_restritiva',
values_from = 'V0010', # considera o peso
values_fn = sum
) %>%
select(-V0011) %>%
# agrega as matrizes n zonas vezes
slice(rep(1, each = length(setores))) %>%
as.matrix(.)
# define os nomes
rownames(weight_init) <- setores
# reordena as colunas
weight_init <- weight_init[, var_restritivas]
# alvo de valores totais de cada setor
target <- list(as.matrix(universo_ap))
# ordem das variáveis restritivas
descript <- list(1:2)
## implementação do Ipf ----
weight_mipfp <- Ipfp(seed = weight_init,
target.list = descript,
target.data = target,
na.target = T, tol = 1e-5,
print = T)
